import { ExportTraceServiceRequest } from "./proto/collector/trace/v1/trace_service";
import { KeyValue } from "./proto/common/v1/common";
import { Span_SpanKind, Status_StatusCode } from "./proto/trace/v1/trace";

export enum SpanKind {
  SPAN_KIND_UNSPECIFIED = "unspecified",
  SPAN_KIND_INTERNAL = "internal",
  SPAN_KIND_SERVER = "server",
  SPAN_KIND_CLIENT = "client",
  SPAN_KIND_PRODUCER = "producer",
  SPAN_KIND_CONSUMER = "consumer",
}

export type SimpleAnyValue =
  | string
  | number
  | boolean
  | undefined
  | Array<SimpleAnyValue>
  | { [key: string]: SimpleAnyValue }
  | Uint8Array;

/**
 * A simple span, meant to be consumed by human beings.
 * All data is transformed to be most human friendly, compact and easy to make sense of.
 *
 */
export interface SimpleSpan {
  // traceId as string. Always present.
  // For otel generated traces, this is a 32 character hex string, but for traces from other sources it can be anything.
  // All spans with the same traceId are part of the same trace.
  traceId: string;

  // spanId as string. Always present.
  // For otel generated traces, this is a 16 character hex string, but for traces from other sources it can be anything.
  // Each span has a unique spanId.
  spanId: string;

  // parentSpanId as string, or null for root span. Every span that is not a root span has a parentSpanId, but it is not guaranteed that the parentSpanId is found in the database.
  // For otel generated traces, this is a 16 character hex string, but for traces from other sources it can be anything.
  // The parentSpanId is the span in the trace which was active in the context when this span started.
  // In the trace, this span is a child of the span with the parentSpanId.
  parentSpanId?: string;

  // the kind of a span as a string.
  // Value is one of: "client", "server", "producer", "consumer", "internal", "unknown"
  kind: SpanKind;

  // each span has a name, which should follow semantic conventions, but in practice it can be anything
  // and is generally not very useful
  name: string;

  // the start and end times of the span as a string.
  // The format is "YYYY-MM-DDTHH:MM:SS.SSSZ"
  // Example: "2021-08-31T12:34:56.789Z"
  // TODO: support nanoseconds
  startTime: string;
  endTime: string;

  // the duration of the span in milliseconds.
  // since start and end times are in nano seconds, the below ms duration can be fractional.
  // ms is the most convenient unit for humans and for time scales of distributed systems.
  // this value must be consistent with the start and end times, and is a calculated value for convenience only.
  durationMs: number;

  // the service name of the application that generated this span, as reported in the resource attribute "service.name".
  // this value is extracted for convenience and because it is a common and fundamental attribute of a span.
  serviceName: string;

  // resource attributes for this span as a key-value map.
  resourceAttributes: { [key: string]: SimpleAnyValue };

  // the name of the instrumentation scope (instrumentation library) that generated this span.
  // this value is expected to contain a low cardinality value which is a constant for all spans generated by the same instrumentation library,
  // but users can generally store any value they want here.
  scopeName: string;

  // the version of the instrumentation scope (instrumentation library) that generated this span.
  // this value is optional and might be missing if not reported by the source.
  scopeVersion?: string;

  // span attributes for this span as a key-value map.
  spanAttributes: { [key: string]: SimpleAnyValue };

  // indicates if the span status is set as error.
  // if true, the span is considered to record an operation that failed.
  // if false, the span is considered to record an operation that succeeded.
  // if not present or null, the status is unknown or not reported.
  // this representation treats opentelemetry "UNSET" and "OK" statuses as success, and does not differentiate between them.
  spanStatusError?: boolean;

  // if the span status is set as error, this field can contain a human readable message about the error.
  // it is not guaranteed to be present, even if spanStatusError is true.
  spanStatusMessage?: string;
}

const otlpSpanKindToSimpleSpanKind = (kind: Span_SpanKind): SpanKind => {
  switch (kind) {
    case Span_SpanKind.SPAN_KIND_INTERNAL:
        return SpanKind.SPAN_KIND_INTERNAL;
    case Span_SpanKind.SPAN_KIND_SERVER:
        return SpanKind.SPAN_KIND_SERVER;
    case Span_SpanKind.SPAN_KIND_CLIENT:
        return SpanKind.SPAN_KIND_CLIENT;
    case Span_SpanKind.SPAN_KIND_PRODUCER:
        return SpanKind.SPAN_KIND_PRODUCER;
    case Span_SpanKind.SPAN_KIND_CONSUMER:
        return SpanKind.SPAN_KIND_CONSUMER;
    default:
        return SpanKind.SPAN_KIND_UNSPECIFIED;
    }
}

const otlpAnyValueToSimpleValue = (value: any): SimpleAnyValue => {
  if (value.stringValue != null) {
    return value.stringValue;
  } else if (value.boolValue != null) {
    return value.boolValue;
  } else if (value.intValue != null) {
    return Number(value.intValue);
  } else if (value.doubleValue != null) {
    return value.doubleValue;
  } else if (value.arrayValue != null) {
    return value.arrayValue.values.map(otlpAnyValueToSimpleValue);
  } else if (value.kvlistValue != null) {
    const obj: { [key: string]: SimpleAnyValue } = {};
    for (const kv of value.kvlistValue.values) {
      obj[kv.key] = otlpAnyValueToSimpleValue(kv.value);
    }
    return obj;
  } else if (value.bytesValue != null) {
    return value.bytesValue;
  } else {
    return undefined;
  }
};

const otlpAttributesToMap = (
  attrs?: KeyValue[]
): { [key: string]: SimpleAnyValue } => {
  if (!attrs) {
    return {};
  }

  const resourceMap: { [key: string]: SimpleAnyValue } = {};
  for (const attribute of attrs) {
    resourceMap[attribute.key] = otlpAnyValueToSimpleValue(attribute.value);
  }
  return resourceMap;
};

const idsByteArrayToHexString = (idBytes: Uint8Array): string => {
  return Array.from(idBytes)
    .flatMap((byte) => {
      const hi = (byte & 0xf0) >> 4;
      const lo = byte & 0x0f;
      return [hi, lo];
    })
    .map((n) => n.toString(16))
    .join("");
};

const nanosToFullISOString = (nanos: bigint): string => {
  // extract seconds and nanoseconds as bigints
  const seconds = nanos / 1_000_000_000n;
  const nanoseconds = nanos % 1_000_000_000n;

  // convert seconds to milliseconds for Date
  const millis = Number(seconds) * 1000;
  const date = new Date(millis);

  // format the ISO string (default is milliseconds)
  const isoString = date.toISOString();

  // remove milliseconds and "Z" part of the string in order to add nanoseconds ".123Z"
  const isoStringWithoutMillis = isoString.slice(0, -5);

  // format nanoseconds to 9 digits, ensuring leading zeros
  const nanoStr = nanoseconds.toString().padStart(9, "0");

  return `${isoStringWithoutMillis}.${nanoStr}Z`;
};

const spanStatusToIsError = (otlpValue?: Status_StatusCode): boolean | undefined => {
    switch (otlpValue) {
        case Status_StatusCode.STATUS_CODE_UNSET:
            return undefined;
        case Status_StatusCode.STATUS_CODE_OK:
            return false;
        case Status_StatusCode.STATUS_CODE_ERROR:
            return true;
        default:
            return undefined;
    }
}

export const traceServiceRequestToSimpleSpans = (
  traceServiceRequest: ExportTraceServiceRequest
): SimpleSpan[] => {
  const spans: SimpleSpan[] = [];
  for (const resourceSpans of traceServiceRequest.resourceSpans) {
    const resourceAttributes = otlpAttributesToMap(
      resourceSpans.resource?.attributes
    );
    for (const scopeSpans of resourceSpans.scopeSpans) {
      for (const span of scopeSpans.spans) {
        const traceId = idsByteArrayToHexString(span.traceId);
        const spanId = idsByteArrayToHexString(span.spanId);
        const parentSpanId =
          span.parentSpanId.length > 0
            ? idsByteArrayToHexString(span.parentSpanId)
            : undefined;
        const spanAttributes = otlpAttributesToMap(span.attributes);
        const kind = otlpSpanKindToSimpleSpanKind(span.kind);
        const durationMs = Number(span.endTimeUnixNano - span.startTimeUnixNano) / 1_000_000;
        const spanStatusError = spanStatusToIsError(span.status?.code);
        const serviceName = resourceAttributes["service.name"] as string;

        const simpleSpan: SimpleSpan = {
          traceId,
          spanId,
          parentSpanId,
          kind,
          name: span.name,
          startTime: nanosToFullISOString(span.startTimeUnixNano),
          endTime: nanosToFullISOString(span.endTimeUnixNano),
          durationMs,
          serviceName,
          resourceAttributes,
          scopeName: scopeSpans.scope?.name!,
          scopeVersion: scopeSpans.scope?.version,
          spanAttributes,
          spanStatusError,
          spanStatusMessage: span.status?.message || undefined,
        };
        spans.push(simpleSpan);
      }
    }
  }
  return spans;
};
